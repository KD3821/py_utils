Задание 1:
Опишите словами алгоритм решения задачи

Ввод: натуральное число n
Вывод: количество простых чисел строго меньше n

Решение должно быть вычислительно-эффективным

Ответ:
Считываем значение из ввода, преобразуем его в integer, создаем переменную "n" и присваиваем ей это значение.
Создаем массив чисел от нуля до n (n не включаем) - назовем его 'list1'
Создаем пустой массив - назовем его 'list2' - это наш "результирующий список".
Производим итерацию по массиву 'list1' и проверяем каждый элемент на равенство нулю остатка от деления элемента на 2. Если такой остаток не равен нулю - добавляем элемент в ранее созданный "результирующий" список 'list2'. В противном случае переходим к следующему элементу и повторяем проверку условия.
После завершения итерации создаем переменную "а" и присваиваем ей значение длины полученного "результирующего списка" - 'list2' - это и есть количество простых чисел строго меньше n.
Выводим значение переменной "a".


##############################
Задание 2:
Дан неупорядоченный массив из печатных ASCII символов
Опишите своими словами (без кода и псевдокода) алгоритм сортировки, позволяющий упорядочить этот массив по алфавиту за линейное время
Необходимо описать действия на каждом шаге алгоритма
Возможен ли стабильный вариант такого алгоритма сортировки?

Ответ:

Назовем данный массив 'arr'.
Так как в массиве могут быть символы как в нижнем так и в верхнем регистре, для сортировки в алфавитном порядке будем приводить каждый символ в нижнем регистре к символу в верхнем регистре. Для этого создадим словарь 'dict', у которого в качестве ключей будут символы в нижнем регистре, а значениями будут символы в верхнем регистре - например { 'a': 'A', 'b': 'B'...}.
Создадим копию массива и назовем его 'arr_copy' и далее мы будем работать с его элементами - это наш "рабочий" массив. Также создадим пустой массив, назовем его 'arr_done' - это будет наш "результирующий" массив, куда мы будем добавлять отсортированные в алфавитном порядке символы.
Так как каждый ASCII символ имеет соответствующее цифровое значение, и в стандарте ASCII алфавитный порядок соответствует числовому порядку (то есть 'A' имеет минимальное цифровое значение, а символ 'Z' максимальное), то мы будем использовать эти цифровые значения для сортировки в алфавитном порядке. Будем также иметь ввиду, что в стандарте ASCII символы в нижнем регистре начинаются с числа '97' для символа 'a', и заканчиваются числом '122' для символа 'z', но для символов в верхнем регистре - '65' для 'A' и '90' для 'Z'. Именно по этой причине мы будем приводить символы в нижнем регистре к символам в верхнем регистре с помощью словаря 'dict'.
Запускаем главный цикл алгоритма - цикл 'while' пока выполняется условие, что массив 'arr_copy' не пустой. 
В теле цикла while мы берем первый элемент массива 'arr_copy' и проверяем является ли он символом в нижнем регистре - то есть является ли он ключом одного из элементов словаря 'dict'. 
Если да - берем значение по ключу, преобразуем его из символа ASCII в соответствующее цифровое значение и записываем в переменную 'min' и при этом записываем в переменную 'index_m' значение индекса первого элемента в рабочем массиве 'arr_copy'.
Если же нет (то есть ASCII символ первого элемента массива 'arr_copy' имеет верхний регистр), то преобразуем первый элемент массива 'arr_copy' из символа ASCII в соответствующее цифровое значение и записываем  в переменную 'min' и записываем в переменную 'index_m' значение его индекса в рабочем массиве 'arr_copy'.
И далее запускаем итерацию 'for .. in' по всем элементам массива 'arr_copy' кроме первого элемента (его значение уже хранится в переменной 'min' поэтому итерация по 'arr_copy[1:]' ) и сравниваем значение в переменной 'min' с соответствующим цифровым значением ASCII символа, хранящегося в каждом элементе.
То есть - в каждой итерации мы присваиваем переменной 'х' значение текущего элемента массива 'arr_copy[1:]'. 
Далее проверяем, "условие 1", если элемент является ключом словаря 'dict', то есть является ли символом в нижнем регистре. 
Если да, то обновляем переменную 'х' - присваиваем ей соответствующее ключу значение из словаря 'dict'. Таким образом начинаем работать с тем же алфавитным символом, но в верхнем регистре.
И затем преобразуем этот символ ASCII в соответствующее цифровое значение и проверяем является ли оно меньше значения переменной 'min'. 
Если да, то присваиваем переменной 'min' это значение  (обновляем 'min') и присваиваем переменной 'index_m' значение индекса обрабатываемого элемента в рабочем массиве 'arr_copy' (обновляем 'index_m') и далее переходим к следующей итерации по массиву 'arr_copy[1:]. Если нет (оно больше или равно значению переменной 'min'), то сразу переходим к следующей итерации 'for...in'.
Если "условие 1" не выполнилось, то есть в переменной 'x' символ АSCII все же имеет верхний регистр, то проверяем "условие 2" - меньше ли цифровое значение соответствующее этому символу ASCII значения в переменной 'min'. 
Если да, то присваиваем переменной 'min' это значение  (обновляем 'min') и присваиваем переменной 'index_m' значение индекса обрабатываемого элемента в рабочем массиве 'arr_copy' (обновляем 'index_m') и далее переходим к следующей итерации по массиву 'arr_copy[1:]. Если нет (оно больше или равно значению переменной 'min'), то сразу переходим к следующей итерации 'for...in'.
После завершения итерации 'for...in' по всем элементам массива 'arr_copy[1:]' в переменной 'min' будет храниться самое минимальное цифровое значение, которое соответствует самому первому в алфавитном порядке символу ASCII, хранящемуся в нашем "рабочем" массиве 'arr_copy' в элементе под индексом 'index_m'.
Далее мы добавляем этот элемент в на "результирующий" массив 'arr_done', а из нашего "рабочего" массива 'arr_copy' мы его удаляем.
Так мы завершили наш первый проход по главному циклу алгоритма  -  цикл 'while' пока выполняется условие, что массив 'arr_copy' не пустой. 
Далее начинаем второй проход. Только теперь наш "рабочий" массив 'arr_copy' стал меньше на один элемент, в котором хранилcя самый первый в алфавитном порядке символ ASCII. По завершении второго прохода и последующих проходов в "результирующий" массив 'arr_done' будет добавляться  элемент из 'arr_copy', в котором хранитcя самый первый в алфавитном порядке символ ASCII из оставшихся. А из "рабочего" массива 'arr_copy' этот элемент будет удаляться. И так будет происходить пока будет выполнятся условия цикла while - что массив 'arr_copy' не пустой. По завершению работы цикла 'while' у нас будет "результирующий" массив 'arr_done', который является отсортированным в алфавитном порядке массивом 'arr'.Присваиваем массиву 'arr' массив 'arr_done' - сортировка окончена.

Да. Стабильный вариант возможен.

программа на Python:
arr = [ 'L','p', 'E', 'm', 'F', 'K', 'D', 'S', 'd', 'A', 'M', 'P', 's', 'Z', 'Q', 'T', 'S', 'a']
dict = { 'l':'L', 'e':'E', 'f':'F', 'k':'K', 'd':'D', 's':'S', 'a':'A', 'm':'M', 'p':'P', 'z':'Z', 'q':'Q', 't':'T', 's':'S', 'a':'A'}
arr_done = []
arr_copy=arr.copy()
while arr_copy != []:
    i = arr_copy[0]
    if i in dict.keys():
        x=(dict[i])
        min = ord(x)
        index_m = arr_copy.index(i) 
    else:
        min = ord(i)
        index_m = arr_copy.index(i)
    for mem in arr_copy[1:]:
        x = mem
        if mem in dict.keys():
            x=(dict[mem])
            if ord(x) < min:
                index_m = arr_copy.index(mem)
                min = ord(x)
        else:
            if ord(x) < min:
                index_m = arr_copy.index(mem)
                min = ord(x)
    arr_done.append(arr_copy[index_m])
    arr_copy.pop(index_m)
arr=arr_done


##############################
Задание 3:
Дан массив неповторяющихся чисел, который был отсортирован, а затем циклически сдвинут на неизвестное число позиций.
Опишите без кода и псевдокода алгоритм поиска максимума в таком массиве
Оцените сложность предложенного алгоритма
Изменится ли сложность если массив содержит повторяющиеся числа?

Ответ:
Алгоритм поиска максимума в указанном в задаче массиве будет состоять из проверки условия и применения к массиву двух процедур: "Получение решения" и "Сортировка массива".

Описание алгоритма:
 
Проверяем основное условие "Если длина массива меньше или равна 2".

Если условие выполняется, запускаем процедуру "Получение решения". Если не выполняется, запускаем процедуру "Сортировка массива"

Описание процедуры "Получение решения":
Проверяем, если "длина массива меньше 2".
Если да, то задача решена, так как в массиве всего один элемент и он является максимумом. 
Если нет, то в массиве всего 2 элемента. Тогда проверяем условие, "если первый элемент массива больше второго". 
Если да, то применяем метод массива 'reverse' и получаем отсортированный массив из двух элементов, последний элемент которого является максимумом.
Если нет, то массив уже отсортирован и последний элемент массива является максимумом.
Результат применения к массиву процедуры "Получение решения" - отсортированный массив из одного или двух элементов.

Описание процедуры "Сортировка массива":
Берем средний элемент из массива как "опорный". Создаем два пустых массива с условными названиями "больше чем" и "меньше чем". И далее сравниваем каждый элемент массива (исключая опорный элемент) с опорным элементом и проверяем на условие "больше или меньше". Если элемент больше опорного - добавляем его в массив "больше чем", если меньше - добавляем его в массив "меньше чем". 
Теперь у нас есть "опорный" элемент и два массива - "больше чем" и "меньше чем".
Результат применения к массиву процедуры "Сортировка массива" - это сумма трех элементов: 
- массива "меньше чем", к которому предварительно нужно применить наш алгоритм (то есть рекурсивно проверить основное условие "Если длина массива меньше или равна 2" и применить к массиву либо процедуру "Получения решения" с результатом в виде отсортированного массива, либо процедуру "Сортировка массива"  с результатом в виде суммы трех элементов с рекурсивным применением алгоритма к массивам);
- "опорного" элемента; 
- массива "больше чем", к которому предварительно нужно применить наш алгоритм (то есть рекурсивно проверить основное условие "Если длина массива меньше или равна 2" и применить к массиву либо процедуру "Получения решения" с результатом в виде отсортированного массива, либо процедуру "Сортировка массива"  с результатом в виде суммы трех элементов с рекурсивным применением алгоритма к массивам).

В результате применения алгоритма после завершения всех рекурсивных вызовов мы получим указанный в задаче массив, но отсортированный, последний элемент которого и будет максимумом.

Описан алгоритм быстрой сортировки.
Сложность алгоритма O(n log n).
Если массив содержит повторяющиеся числа - сложность изменится.


##############################
Задание 4:
Напишите регулярное выражение, которое позволяет выделить все строки отвечающие условиям:

Состоят только из букв
Одна и только одна из букв является заглавной

Пример строк которые могут быть выделены выражением:

"Мама",
"авТо",
"гриБ",
'Яблоко', 'яБлоко', 'ябЛоко', 'яблОко', 'яблоКо', 'яблокО'

Пример строк которые не должны быть выделены выражением:

"агент007" - содержит цифры
"стриж" - только строчные буквы
"ГТО", - более одной заглавной буквы
"Три богатыря" - содержит пробел, допустимы только буквы

Ответ:
([а-я]+[А-Я]{1}[а-я]+|[А-Я]{1}[а-я]+|[а-я]+[А-Я]{1})$


##############################
Задание 5:
	
Дан указатель на корень двоичного дерева
Опишите словами алгоритм, который вернёт True если дерево является двоичным деревом поиска и False если не является

Вершина дерева содержит целочисленное значение (value) и два указателя на поддеревья (left и right).

В виде структуры на языке C это можно записать так:

struct node {
  int value;
  node* left;
  node* right;
}

Ответ:
Если значение value вершины дерева больше аналогичного значения value дочернего узла left и в то же время меньше или равно 
аналогичного значения value дочернего узла right, тогда дерево является двоичным деревом поиска и возвращаем True. Если хотя бы одно 
из этих условий нарушено, тогда дерево не является двоичным деревом поиска и возвращаем False.


##############################
Задание 6:

В реляционной базе данных существуют таблицы:

Cities - список городов

id - первичный ключ
name - название
population - численность населения
founded - год основания
country_id - id страны

Countries - список стран

id - первичный ключ
name - название
population - численность населения
gdp - валовый продукт в долларах

Companies - компании

id - первичный ключ
name - название
city_id - город в котором находится штаб-квартира
revenue - годовая выручка в долларах
labors - численность сотрудников

Постройте таблицу, где для каждой страны посчитано число компаний, удволетворяющих условиям:

1) штаб квартира компании находится в этой стране
2) число сотрудников компании не менее 1000 человек

Ответ:
SELECT countries.name, COUNT(companies.id)
FROM countries
JOIN cities
ON countries.id=cities.country_id
JOIN companies
ON cities.id=companies.city_id
WHERE companies.labors >= 1000
GROUP BY countries.id;
